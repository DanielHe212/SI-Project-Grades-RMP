package stats.webscraping;

import java.io.*;
import java.util.ArrayList;
import java.util.HashMap;

public class TidMatching {

    //parameter: file path of ratemyprofessors data generated by RateMyProfessors.getAllProfessors()
    //returns: hashmap with keys made of lowercase names pointing to ratemyprofessors.com tid values
    public static HashMap<String, String> genNameMap(ArrayList<String[]> profs){
        HashMap<String, String> output = new HashMap<>();
        for(String[] ln : profs){
            /* Due to differences in name formatting between UBCgrades and RateMyProfessors, we
             * are only using the first and last name, all lowercase, to match names. Some names can't be
             * matched this way, but the remaining dataset is still sufficiently large for our purposes.
             * Both datasets will be post-processed during the matching process in accordance to this.
             * Some professors may have their middle names stored with their first names, for example,
             * Levin, M. Simon, whose middle name was empty but had the first name "M. Simon". These will
             * not be detected here but would also not be matched to any processed name from the UBCgrades
             * data.
             */
            String name = ln[2] + " " + ln[0]; //first name + last name
            name = name.toLowerCase();
            output.put(name, ln[3]); //ln[3] is tid
        }
        return output;
    }

    //parameter: file path of ratemyprofessors data generated by UBCGrades.getAllSectionsData()
    //returns: the original arraylist generated by UBCGrades.getAllSectionsData()
    public static ArrayList<String[]> makeGradesMap(String filepath){
        ArrayList<String[]> output = new ArrayList<>();
        File profs = new File(filepath);
        try {
            BufferedReader in = new BufferedReader(new FileReader(profs));
            String line = in.readLine();
            while(line != null){
                //splitting the line into year, session, subject, course, section, educators, average, stdev, high, low
                String[] ln = line.split(",");
                output.add(ln);
                line = in.readLine();
            }
        } catch (FileNotFoundException e) {
            System.out.println("RateMyProfessors data file not found at path " + filepath);
            e.printStackTrace();
        } catch (Exception e) {
            System.out.println("Error");
            e.printStackTrace();
        }
        return output;
    }

    //parameter: a string containing a list of educators from UBCgrades
    //returns: a string containing the same list of educators, each formatted through reformatName()
    public static String formatEducators(String s) {
        String[] names = s.split(";");
        String output = "";
        for(int i = 0; i < names.length; i++){
            output += ";" + reformatName(names[i]);
        }
        return output.substring(1);
    }

    //parameter: a string of a person's full name
    //returns: first name and last name separated by a space, all lowercase
    /* this may misformat cases of names with Sr. or Jr. behind the names and other strange name formatting,
     * causing them to not be matched properly with names from the the ratemyprofessors data set, but this
     * is a small minority of cases and can be ignored as the remaining dataset is still sufficiently large.
     */
    public static String reformatName(String name){
        String[] parts = name.split(" ");
        String newname = parts[0] + " " + parts[parts.length - 1];
        return newname.toLowerCase();
    }

    //parameter: arraylist of string arrays - section data
    //returns: the same arraylist but filtered for sections that don't have professors or are from before 2016 sessions
    public static ArrayList<String[]> filteredSectionDataClone(ArrayList<String[]> sectionData){
        ArrayList<String[]> clone = new ArrayList<>();
        for(String[] section : sectionData){
            String[] newSection = section.clone();
            if(newSection[5].length() == 0 || newSection[4].equals("OVERALL")){ //professor-less or combined sections, useless to us
                continue;
            }
            if(Integer.parseInt(newSection[0]) < 2016){
                continue;
            }
            newSection[5] = formatEducators(newSection[5]);
            clone.add(newSection);
        }
        return clone;
    }

    //parameter: sections data from UBCGrades.getAllSectionsData(), a name map from genNameMap()
    //returns: a clone of the section data from UBCGrades but with educator names replaced by tid.
    //no matches or multiple matches for a single section are filtered out, the first case is useless, the second
    //case is difficult to properly handle.
    public static ArrayList<String[]> genMatchedSet(ArrayList<String[]> sectionData, HashMap<String, String> nameMap){
        ArrayList<String[]> filteredData = filteredSectionDataClone(sectionData);

        System.out.println("Section data size: " + sectionData.size()); // for curiosity sake
        System.out.println("Filtered data size: " + filteredData.size()); // for curiosity sake

        ArrayList<String[]> matchedData = new ArrayList<>();


        for(String[] section : filteredData){
            String[] names = section[5].split(";");
            String match = "";
            for(String name : names){
                if(nameMap.containsKey(name)){
                    if(match.equals("")){
                        match = nameMap.get(name);
                    }
                    else if(match.length() > 0){
                        match = "multiple";
                        break;
                    }
                }
            }
            if(match.length() > 0 && !match.equals("multiple")){
                String[] cloneSection = section.clone();
                cloneSection[5] = match;
                matchedData.add(cloneSection);
            }
        }

        System.out.println("Matched data size: " + matchedData.size()); // for curiosity sake

        return matchedData;
    }
}